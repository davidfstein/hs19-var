<html>
  <head>
    <script src="https://aframe.io/releases/0.9.2/aframe.min.js"></script>

    <!-- <script src="https://rawgit.com/protyze/aframe-curve-component/master/dist/aframe-curve-component.min.js"></script> -->
    <!-- <script src="https://rawgit.com/protyze/aframe-alongpath-component/master/dist/aframe-alongpath-component.min.js"></script> -->
    <script src="https://unpkg.com/aframe-curve-component/dist/aframe-curve-component.min.js"></script>
    <!-- adding an environment -->
    <script src="https://unpkg.com/aframe-environment-component@1.1.0/dist/aframe-environment-component.min.js"></script>

    <!-- wasd-controls -->
    <script>
        var bind = AFRAME.utils.bind;
        var shouldCaptureKeyEvent = AFRAME.utils.shouldCaptureKeyEvent;

        var CLAMP_VELOCITY = 0.00001;
        var MAX_DELTA = 0.2;
        var KEYS = [
            'KeyW', 'KeyA', 'KeyS', 'KeyD'
        ]
        AFRAME.registerComponent('stream-wasd-controls', {
        schema: {
            acceleration: {default: 65},
            adAxis: {default: 'x', oneOf: ['x', 'y', 'z']},
            adEnabled: {default: true},
            adInverted: {default: false},
            easing: {default: 20},
            enabled: {default: true},
            fly: {default: false},
            head: {type: 'selector'},
            wsAxis: {default: 'z', oneOf: ['x', 'y', 'z']},
            wsEnabled: {default: true},
            wsInverted: {default: false}
        },

        init: function () {
            // To keep track of the pressed keys.
            this.keys = {};

            this.position = {};
            this.velocity = new THREE.Vector3();
        },

        tick: function (time, delta) {
            var currentPosition;
            var data = this.data;
            var el = this.el;
            var movementVector;
            var position = this.position;
            var velocity = this.velocity;

            if (!velocity[data.adAxis] && !velocity[data.wsAxis] &&
                isEmptyObject(this.keys)) { return; }

            // Update velocity.
            delta = delta / 1000;
            this.updateVelocity(delta);

            if (!velocity[data.adAxis] && !velocity[data.wsAxis]) { return; }

            // Get movement vector and translate position.
            currentPosition = el.getAttribute('position');
            movementVector = this.getMovementVector(delta);
            position.x = currentPosition.x + movementVector.x;
            position.y = currentPosition.y + movementVector.y;
            position.z = currentPosition.z + movementVector.z;
            el.setAttribute('position', position);
        },

        remove: function () {
            this.removeKeyEventListeners();
            this.removeVisibilityEventListeners();
        },

        play: function () {
            this.attachKeyEventListeners();
        },

        pause: function () {
            this.keys = {};
            this.removeKeyEventListeners();
        },

        updateVelocity: function (delta) {
            var acceleration;
            var adAxis;
            var adSign;
            var data = this.data;
            var keys = this.keys;
            var velocity = this.velocity;
            var wsAxis;
            var wsSign;

            adAxis = data.adAxis;
            wsAxis = data.wsAxis;

            // If FPS too low, reset velocity.
            if (delta > MAX_DELTA) {
                velocity[adAxis] = 0;
                velocity[wsAxis] = 0;
                return;
            }

            // Decay velocity.
            if (velocity[adAxis] !== 0) {
                velocity[adAxis] -= velocity[adAxis] * data.easing * delta;
            }
            if (velocity[wsAxis] !== 0) {
                velocity[wsAxis] -= velocity[wsAxis] * data.easing * delta;
            }

            // Clamp velocity easing.
            if (Math.abs(velocity[adAxis]) < CLAMP_VELOCITY) { velocity[adAxis] = 0; }
            if (Math.abs(velocity[wsAxis]) < CLAMP_VELOCITY) { velocity[wsAxis] = 0; }

            if (!data.enabled) { return; }

            // Update velocity using keys pressed.
            acceleration = data.acceleration;
            if (data.adEnabled) {
                adSign = data.adInverted ? -1 : 1;
                if (keys.KeyA || keys.ArrowLeft) { velocity[adAxis] -= adSign * acceleration * delta; }
                if (keys.KeyD || keys.ArrowRight) { velocity[adAxis] += adSign * acceleration * delta; }
            }
            if (data.wsEnabled) {
                wsSign = data.wsInverted ? -1 : 1;
                if (keys.KeyW || keys.ArrowUp) { velocity[wsAxis] -= wsSign * acceleration * delta; }
                if (keys.KeyS || keys.ArrowDown) { velocity[wsAxis] += wsSign * acceleration * delta; }
            }
        },

        getMovementVector: (function () {
            var directionVector = new THREE.Vector3(0, 0, 0);
            var rotationEuler = new THREE.Euler(0, 0, 0, 'YXZ');

            return function (delta) {
                var rotation = (this.data.head || this.el).getAttribute('rotation');
                var velocity = this.velocity;
                var xRotation;

                directionVector.copy(velocity);
                directionVector.multiplyScalar(delta);

                // Absolute.
                if (!rotation) { return directionVector; }

                xRotation = this.data.fly ? rotation.x : 0;

                // Transform direction relative to heading.
                rotationEuler.set(THREE.Math.degToRad(xRotation), THREE.Math.degToRad(rotation.y), 0);
                directionVector.applyEuler(rotationEuler);
                console.log(directionVector);
                return directionVector;
            };
        })(),

        attachVisibilityEventListeners: function () {
            window.addEventListener('blur', this.onBlur);
            window.addEventListener('focus', this.onFocus);
            document.addEventListener('visibilitychange', this.onVisibilityChange);
        },

        removeVisibilityEventListeners: function () {
            window.removeEventListener('blur', this.onBlur);
            window.removeEventListener('focus', this.onFocus);
            document.removeEventListener('visibilitychange', this.onVisibilityChange);
        },

        attachKeyEventListeners: function () {
            window.addEventListener('keydown', this.onKeyDown);
            window.addEventListener('keyup', this.onKeyUp);
        },

        removeKeyEventListeners: function () {
            window.removeEventListener('keydown', this.onKeyDown);
            window.removeEventListener('keyup', this.onKeyUp);
        },

        onBlur: function () {
            this.pause();
        },

        onFocus: function () {
            this.play();
        },

        onVisibilityChange: function () {
            if (document.hidden) {
                this.onBlur();
            } else {
                this.onFocus();
            }
        },

        onKeyDown: function (event) {
            var code;
            if (!shouldCaptureKeyEvent(event)) { return; }
            code = event.code || KEYCODE_TO_CODE[event.keyCode];
            if (KEYS.indexOf(code) !== -1) { this.keys[code] = true; }
        },

        onKeyUp: function (event) {
            var code;
            code = event.code || KEYCODE_TO_CODE[event.keyCode];
            delete this.keys[code];
        }
        });

        function isEmptyObject (keys) {
            var key;
            for (key in keys) { return false; }
            return true;
        }

        // Experimenting with click to change element colour
        AFRAME.registerComponent('cursor-listener', {
    init: function () {
    var lastIndex = -1;
    var COLORS = ['red', 'green', 'blue'];
    this.el.addEventListener('click', function (evt) {
      lastIndex = (lastIndex + 1) % COLORS.length;
      this.setAttribute('material', 'color', COLORS[lastIndex]);
      console.log('I was clicked at: ', evt.detail.intersection.point);
    });
  }
});
    </script>
  </head>
  <body>


    <a-scene>
        <a-camera position="0 0 0" look-controls wasd-controls="acceleration: 20">
                <!-- Scope/cursor remains centered on screen at all times -->
                  <a-cursor id="cursor"></a-cursor>
        </a-camera>
        <a-camera position="0 0 0" look-controls wasd-controls="acceleration: 20"></a-camera>


        <a-curve id="track1"></a-curve>

        <!-- <a-box alongpath="curve: #track1; loop: true"></a-box> -->
        <a-draw-curve curveref="#track1" material="shader: line; color: blue;"></a-draw-curve>
        <a-entity position="0 0 0" id="cells"></a-entity>
	
	<!-- adding a backdrop -->
	<a-entity environment="skyType: atmosphere; skyControl: #FFFFFF; groundTexture: checkerboard; groundColor: #f3f3f2; groundColor2: #e7e74; shadow: on; dressing: cylinder; dressingAmount: 15; dressingColor: #7c5c45; grid: xlines; gridColor: #000000"></a-entity>
        
	<!-- Adding 2 planes and a light source for orientation clarity  -->
        <a-plane position="0 0 -0.5" rotation="0 0 0" width="1" height="1" color="#a0d6d6" transparent="true" opacity="0.5" material="side: double"></a-plane>
	<a-plane position="0 -0.1 -0.1" rotation="-90 0 0" width="1" height="1" color="#a0d6d6" transparent="true" opacity="0.5" material="side: double"></a-plane>
	
        <a-entity light="type: directional; color: #AFA; intensity: 2.4" position="0 0 1"></a-entity>
    </a-scene>
    <script>

      const getCurvePoints = () => {
        return fetch('data/curves.json')
          .then(response => response.text())
          .then(text => {
            const coords = JSON.parse(text);
            const curvePoints = [];
            coords.forEach((coord, _) => {
                const curvePoint = `<a-curve-point position="${coord.x} ${coord.y} ${coord.z}"></a-curve-point>`;
                curvePoints.push(curvePoint);
            });
            return curvePoints;
          });
      }

      const getCells = () => {
          return fetch('data/cells.json')

            .then(response => response.text())
            .then(text => {
                const coords = JSON.parse(text);
                const curvePoints = [];
                coords.forEach((coord, _) => {
                    const curvePoint = `<a-curve-point position="${coord.x} ${coord.y} ${coord.z}"></a-curve-point>`;
                    curvePoints.push(curvePoint);
                });  
                return curvePoints;
            });
        }

        const getCells = () => {
            return fetch('data/cells.json')
                .then(response => response.text())
                .then(text => {
                    const cell_points = JSON.parse(text);
                    const cells = [];
                    cell_points.forEach((cell_point, _) => {
                        const stream_cell = `<a-sphere position="${cell_point.x} ${cell_point.y} ${cell_point.z}" color="${cell_point.color}" radius=".001" shadow></a-sphere>`;
                        cells.push(stream_cell);
                    })
                    return cells;
                });
        }

        getCurvePoints()
            .then((curvePoints) => {
            const curve_el = document.getElementById("track1");
            curve_el.innerHTML = curvePoints.join(" ");
            });

        getCells()
            .then((cells) => {
            const cell_el = document.getElementById("cells");
            cell_el.innerHTML = cells.join(" ");
            });


        const scene = document.getElementById("test");   
        let clickCount = 0; 
        scene.addEventListener("click", () => {
            currentState = states[clickCount % states.length];
            clickCount = clickCount + 1;        
        });

        let positionIndex = 0
        const moveForward = (positions) => {
            if (positionIndex !== positions.length) {
                const camera_el = document.getElementById("curve-camera");
                position = positions[positionIndex];
                camera_el.setAttribute("position", position);
                positionIndex = positionIndex + 1; 
            }
        }

        const moveBackward = (positions) => {
            if (positionIndex !== 0) {
                const camera_el = document.getElementById("curve-camera");
                position = positions[positionIndex];
                camera_el.setAttribute("position", position);
                positionIndex = positionIndex - 1; 
            }
        }

        document.addEventListener("keydown", event => {
            if (event.keyCode === 38) {
                getCameraTrajectory()
                    .then((positions) => {
                        const camera_el = document.getElementById("curve-camera");
                        position = positions[clickCount];
                        camera_el.setAttribute("position", position);
                        clickCount = clickCount + 1;        
                });
            }
            else if (event.keyCode === 40) {
                getCameraTrajectory()
                    .then((positions) => {
                        const camera_el = document.getElementById("curve-camera");
                        position = positions[clickCount];
                        camera_el.setAttribute("position", position);
                        clickCount = clickCount - 1;        
                });
            }
        });



        getCameraTrajectory()
            .then(positions => {
                setInterval(() => {
                    console.log(currentState);
                    if (currentState === "forward") {
                        moveForward(positions);
                    }
                    else if (currentState === "backward") {
                        moveBackward(positions);
                    }
                }, 1000);
            });
    </script>
  </body>
</html>
